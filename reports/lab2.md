# Lab2 实验报告

## 实现功能

- 

## 简答作业

### 第一题

从低到高十位分别是：

0. V: 表示页表项是否合法，无效则会被MMU忽略；
1. R：表示这个页表项的对应虚拟页面是否允许读；
2. W：表示这个页表项的对应虚拟页面是否允许写；
3. X：表示这个页表项的对应虚拟页面是否允许执行；
4. U：表示这个页表项的对应虚拟页面是否在CPU处于U特权级的情况下是否允许访问；
5. G：全局页表，TLB刷新时会被保留
6. A：处理器记录自从页表项上的这一位被清零之后，页表项对应的虚拟页面是否被访问过；
7. D：处理器记录自从页表项上的这一位被清零之后，页表项对应的虚拟页面是否被修改过；
8. RSW：占两位，未规定用途，可由操作系统利用

[10:53]位是PPN，分成三段：
- [10:18]是PPN[0],长度9位
- [19:27]是PPN[1],长度9位
- [28:53]是PPN[2],长度26位

### 第二题 

特权级文档【3.1.16】`Machine cause register (mcause) values after trap`中有三种与缺页（page fault）有关。

- `12 Instruction page fault` 指令执行错误
- `13 Load page fault` 读取错误
- `15 Store/AMO page fault` 写入或原子内存指令错误

发生缺页时

- `scause` 寄存器会被设置以上三者之一，表示缺页的原因
- `stval` 寄存器保存被访问的目标**地址**。
- `sepc` 寄存器用于存储导致异常的指令的地址

使用Lazy的好处

- 懒加载减少程序初始化耗时
- 减少同一时刻内存的使用量
- 合理的分配应用使用的物理内存，防止应用过度浪费内存资源

### 10G内存页表大小

总页数：
> (10 * 0x4000_0000) / 4096 = 2621440 页


 一页有 2^9 = 512个
>
> 即2621440 / 512 = 5120 页

连续内存页面，即第二层节点大致需要：

> 5120 / 512 = 10 页

第一层需要：

> 10 / 512 = 1 页

用系数大的第三层大致估算：

> 5120 * 4096 = 20971520 / 1024 = 20MiB 左右

### Lazy实现的策略

目前还在研究中，准备实现

## 第三题

1. 单页表的情况下，在__switch中保存当前页表token，并将下一个任务的页表设置到satp中，如此更换页表。

2. 将PTE的第四位字段`U`,设置位0即可

3. 内核态与用户态地址空间相同，trap发生时不必切换，因此TLB仍然效。
    
   内核态可以直接使用来自用户态的指针(sstatus.SUM=1时)，传递数据更加简单且迅速。

4. 双页表实现下，在发生trap时，在进入trap_handler处理前，即`__alltraps` 的尾部，更换页表为内核空间

    在__restore的头部，即恢复状态之前更换页表为任务的地址空间。


如果我来写一个单页表操作系统，会选择在trap发生时判断其trap类型，即异常类型，分别处理，在切换应用进程时更换页表。



# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与以下各位就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

* 无。直到完成为止，我未与任何人交流本章内容。

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

* 手册 [riscv-privileged-20190608-1](https://riscv.org/wp-content/uploads/2019/08/riscv-privileged-20190608-1.pdf)。
* 代码实现并未参考任何已有资料，未使用任何AI生成的代码，代码实现全部由我个人完成。

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。