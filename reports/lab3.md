# Lab3 实验报告

## 功能实现部分

1. 定义了并实现了一个新的系统调用 `sys_spawn`

2. 实现了采用stride调度算法调度进程运行，同时实现了该算法需要的`sys_set_priority`新的系统调用

## 问答作业

- 不是，由于8位无符号整数的限制，计算 p2 的新通行证时会出现溢出。会导致p1.stride溢出，具体要看具体的语言对溢出的处理。

p2 执行，p2.pass 增加10，变成 4（由于溢出）。
p1 执行，p1.pass 增加10，变成 9。

- 如果步长 >= 2，那么每次进程通行证增加至少为2。

    考虑没有溢出的情况，假设有两个进程 p1 和 p2，它们的步长分别为 stride1 和 stride2，并且 stride1 < stride2。
由于步长 >= 2，每次调度后，两个进程的通行证都会增加至少 2，差值保持在一定范围内。
根据推论，当通行证差值达到 BigStride / 2 时，下次调度选择的进程通行证差值将会减少。
这种情况下，通行证差值永远不会超过 BigStride / 2。

```rust

impl PartialOrd for Stride {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        if self.stride < other.stride && other.stride - self.stride > BIG_STRIDE / 2 {
            Some(Ordering::Less)
        } else if other.stride < self.stride && self.stride - other.stride > BIG_STRIDE / 2 {
            Some(Ordering::Greater)
        } else {
            None
        }
    }
}

```

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    一些进程调度的文献

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

